	/**
 * Thunderpush javascript client
 * @version v0.9.0 - 2014-04-11 * @link https://github.com/thunderpush/thunderpush-js
 * @author Krzysztof Jagiełło
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */var isMSIE = 0, Thunder = new function () { this.channels = [], this.handlers = [], this.reconnect_delays = [1e3, 2500, 5e3, 1e4, 3e4, 6e4], this.options = { log: !1, retry: !0 }; var a = Array.prototype, b = Object.prototype, c = Function.prototype, d = (a.push, a.slice, a.concat, b.toString, b.hasOwnProperty, a.forEach, a.map, a.reduce, a.reduceRight, a.filter, a.every, a.some, a.indexOf), e = (a.lastIndexOf, Array.isArray, Object.keys, c.bind, function (a) { return a instanceof e ? a : this instanceof e ? void (this._wrapped = a) : new e(a) }); "function" != typeof /./ && (e.isFunction = function (a) { return "function" == typeof a }), e.identity = function (a) { return a }, e.lookupIterator = function (a) { return e.isFunction(a) ? a : function (b) { return b[a] } }, e.sortedIndex = function (a, b, c, d) { c = null == c ? e.identity : e.lookupIterator(c); for (var f = c.call(d, b), g = 0, h = a.length; h > g;) { var i = g + h >>> 1; c.call(d, a[i]) < f ? g = i + 1 : h = i } return g }, e.indexOf = function (a, b, c) { if (null == a) return -1; var f = 0, g = a.length; if (c) { if ("number" != typeof c) return f = e.sortedIndex(a, b), a[f] === b ? f : -1; f = 0 > c ? Math.max(0, g + c) : c } if (d && a.indexOf === d) return a.indexOf(b, c); for (; g > f; f++)if (a[f] === b) return f; return -1 }, this.onSockOpen = function (a) { "function" == typeof a && (this.onopen = a) }, this.onSockError = function (a) { "function" == typeof a && (this.onerror = a) }, this.onSockClose = function (a) { "function" == typeof a && (this.onclose = a) }, this.onSockMessage = function (a) { "function" == typeof a && (this.onmessage = a) }, this.connect = function (a, b, c, d) { this.server = "http://" + a + "/connect", this.apikey = b, this.channels = c, this.reconnect_tries = 0; for (var e in d) this.options[e] = d[e]; this.user = this.options.user, this.makeConnection() }, this.disconnect = function () { var a = this; return this.socket.onclose = function (b) { this.onclose && this.onclose.call(a, b) }, this.socket.readyState === SockJS.OPEN ? this.socket.close() : !1 }, this.subscribe = function (a, b, c) { if ("string" != typeof a || a.length <= 0) throw { name: "channel.invalid", message: "Channel is not a string" }; if (this.socket.readyState === SockJS.OPEN) return -1 !== e.indexOf(this.channels, a) ? ("function" == typeof b && b(this, "Channel already subscribed"), !0) : (this.socket.send("SUBSCRIBE " + a), this.channels.push(a), "function" == typeof b && b(this, "Channel subscribed"), !0); throw "function" == typeof c && c(this, "Socket not open"), { name: "socket.status", message: "Socket not OPEN: ".this.socket.readyState } }, this.unsubscribe = function (a, b, c) { if (this.socket.readyState === SockJS.OPEN) { this.socket.send("UNSUBSCRIBE " + a); var d = e.indexOf(this.channels, a); return -1 !== d && (channels = this.channels.splice(d, 1)), "function" == typeof b && b(this, "Channel unsubscribed"), !0 } var c = ""; throw "function" == typeof c && c(this, "Socket not open"), { name: "socket.status", message: "Socket not OPEN: ".this.socket.readyState } }, this.listen = function (a) { this.log("New handler has been registered."), this.handlers.push(a) }, this.makeConnection = function () { var a = this; this.socket = new SockJS(this.server, void 0, { debug: this.options.log }), this.socket.onopen = function (b) { a.log("Connection has been estabilished."), a.onopen && a.onopen.call(a, b), a.reconnect_tries = 0, a.socket.send("CONNECT " + a.user + ":" + a.apikey), a.channels.length && a.socket.send("SUBSCRIBE " + a.channels.join(":")) }, this.socket.onmessage = function (b) { a.log("Message has been received", b.data), a.onmessage && a.onmessage.call(a, b); try { var c = JSON.parse(b.data.payload); b.data = c } catch (b) { } for (var d = 0; d < a.handlers.length; d++)a.handlers[d](b.data) }, this.socket.onerror = function (b) { a.onerror && a.onerror.call(a, b) }, this.socket.onclose = function (b) { if (a.log("Connection has been lost."), a.onclose && a.onclose.call(a, b), a.options.retry === !1) return void a.log("Reconnect supressed because of retry option false"); if (9e3 == b.code || 9001 == b.code || 9002 == b.code) return void a.log("Reconnect supressed because of:", b); var c = a.reconnect_delays[a.reconnect_tries] || a.reconnect_delays[a.reconnect_delays.length - 1]; a.log("Reconnecting in", c, "ms..."), a.reconnect_tries++ , setTimeout(function () { a.makeConnection() }, c) } }, this.log = function () { if (this.options.log && "console" in window && "log" in window.console) if (1 == arguments.length) console.log(arguments[0]); else if (isMSIE) { var a = Function.prototype.bind.call(console.log, console); a.apply(console, Array.prototype.slice.call(arguments)) } else console.log.apply(console, Array.prototype.slice.call(arguments)) } };

